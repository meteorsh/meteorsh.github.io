<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构-时间复杂度和空间复杂度分析</title>
      <link href="/posts/123.html"/>
      <url>/posts/123.html</url>
      
        <content type="html"><![CDATA[<div align=center><img src="https://img-blog.csdnimg.cn/20200302184517998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_40,text_cGhvdG8gYnkgc2h3ZWk=,size_25,color_FFFFFF,t_50,g_center" width="30%"/></div><h1 id="研究时间复杂度的重要性"><a href="#研究时间复杂度的重要性" class="headerlink" title="研究时间复杂度的重要性"></a>研究时间复杂度的重要性</h1><p>我们知道CPU提升的速度是很慢的，就算夸张点10年间提升了10000倍<br>如果一个可以有时间复杂度为 $O(n)$ 的算法的程序，我们写成了 $O(n^2)$，那么程序只提升了 $\sqrt {10000}=100$倍 ,而对于$O(n)$时间复杂度的算法却能提升10000倍</p><h1 id="最坏情况和平均情况"><a href="#最坏情况和平均情况" class="headerlink" title="最坏情况和平均情况"></a>最坏情况和平均情况</h1><p><strong>示例：</strong><br>在一个由n个元素的数组中，按顺序查找一个数<br>最好的情况是查找的就是第一个数，复杂度 $O(1)$</p><p>平均运行时间需要从概率来看，也就是期望<br>每个数是查找的概率是 $1/n$ ，然后乘以对应的随机变量<br>期望 $E = 1 * 1/n + 2 * 1/n + … + n * 1/n = (1 + n) / 2$<br>所以平均查找次数是$\frac {(1 + n)} { 2}$次</p><p>最坏情况是这个数字在最后一个位置，所以需要查找n次</p><hr><p>平均运行时间是最有意义的，因为这是一个通常的运行时间，比如除了双十一外的364天，淘宝运行时间都是1秒，但是最坏情况是双十一那天，淘宝运行时间可能是100秒</p><p>最坏情况运行时间是一种保证，也就是说运行时间不会再多了，这在实际应用中是一个很重要的需求，所以<font color=red size=3 face=STHeit>一般我们说的时间复杂度都是指最坏情况的运行时间<br></font></p><h1 id="时间复杂度的渐进表示法"><a href="#时间复杂度的渐进表示法" class="headerlink" title="时间复杂度的渐进表示法"></a>时间复杂度的渐进表示法</h1><p>我们把<strong>语句的总的执行次数记作 $T(n)$</strong><br>$T(n)$是关于问题规模n的函数<br><font color=red size=3 face=STHeit> 大O表示法</font></p><ul><li><p>$T(n) = O(f(n))$表示存在常数$C&gt;0,n_0&gt;0$，使得当$n&gt;=n_0$时有 $T(n) &lt;= Cf(n)$ </p><p>对于充分大的$n$而言，$f(n)$是$T(n)$的某种上界<br>但是一个东西的上界可以有很多个，太大的上界对我们分析算法复杂度没有什么参考意义，我们希望跟真实情况越贴近越好</p></li></ul><blockquote><p>推导大O阶：</p><ol><li>用常数取代运行时间中的所有加数常数</li><li>在修改后的运行次数函数中，只保留最高阶项</li><li>如果最高阶项且不是1，则去除与这个项相乘的常数 得到的结果就是大O阶</li></ol></blockquote><p>例1：$T(n) = 4n^{3}$ + $7n^{2}$ + $53logn$ +  $2$<br>推导大O阶得：$T(n) = O(n^3)$ </p><p>例2：$O(3) = O(1)$</p><p>例3： $O(2logn + n/2) = O(n)$ </p><hr><ul><li>$T(n) = \Omega(g(n))$表示存在常数$C&gt;0,n_0&gt;0$，使得当$n&gt;=n_0$时有 $T(n) &gt;= Cg(n)$</li><li>$T(n) = \theta(h(n))$表示同时有 $T(n) = O(h(n))$和 $T(n) = \Omega(h(n))$   </li></ul><h1 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h1><p>常见的时间复杂度所耗时间的大小排名：<br>$$O(1)&lt;O(logn)&lt;O(n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)$$学数学的时候用的记忆技巧：<strong>对幂指阶超</strong></p><h1 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h1><p>算法空间复杂度的计算公式记作： $S(n) = O(f(n))$ ，其中 $n$ 为问题的规模， $f(n)$为语句关于 $n$ 所占存储空间的函数</p><p>一个程序执行时，除了需要存储程序本身的指令、常数、遍历和输入数据外，还要存储对数据操作的存储单元</p><p>如果输入数据所占空间只取决于问题本身，与算法无关，那我们<font color=red size=3 face=STHeit>只需要分析该算法在实现时所需的辅助空间</font>，也就是<font color=red size=3 face=STHeit>分析额外使用的空间</font>即可</p><hr><p><strong>例1：</strong><br>下面的代码输入数据matrix所占空间与算法优劣没有关系，所以我们只需要看额外的使用空间即可</p><p>这里我们定义了变量：$n、m、d、x、y、a、b$，数组：$dx，dy，res$<br>用大O推导法知$S(N) = O(N)$，其中$N$表示矩阵中的所有元素个数$N=n*m$（<font color=red size=3 face=STHeit>需要$res$数组来存储信息</font>）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findDiagonalOrder</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> dy<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> d <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">*</span> m<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n <span class="token operator">*</span> m<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 利用(a,b)找到下一个可以走的点</span>            <span class="token keyword">int</span> a <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token punctuation">,</span> b <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> a <span class="token operator">>=</span> n <span class="token operator">||</span> b <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> b <span class="token operator">>=</span> m <span class="token operator">||</span> matrix<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">==</span> INT_MAX<span class="token punctuation">)</span> <span class="token punctuation">{</span>                d <span class="token operator">=</span> <span class="token punctuation">(</span>d <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">;</span>                a <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token punctuation">,</span> b <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 让(x,y)变成下一个可走的点，然后进入下一个循环</span>            x <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token punctuation">;</span>            y <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> d <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> d <span class="token operator">=</span> <span class="token punctuation">(</span>d <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例2：</strong><br><a href="https://blog.csdn.net/qq_43827595/article/details/104160450" target="_blank" rel="noopener">剑指offer 旋转数组的最小数字（二分）</a></p><p>这里我额外用到的空间是常数阶的，所以空间复杂度是$O(1)$</p><p>虽然这里用到了rotateArray[i]等数组元素，但这是题目给的输入数据，不是自己额外定义的，所以不用算这一部分</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// 二分：二段性质 可能有重复</span>     <span class="token comment" spellcheck="true">// 3 4 5 1 2 3</span>    <span class="token keyword">int</span> <span class="token function">minNumberInRotateArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rotateArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> rotateArray<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 去重</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> rotateArray<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> rotateArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> j <span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 递增的情况，返回第一个值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> rotateArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> rotateArray<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> rotateArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 二分</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> i<span class="token punctuation">,</span> r <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> r <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rotateArray<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> rotateArray<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> r <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> rotateArray<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MasterTheorem-递归时间复杂度分析</title>
      <link href="/posts/1101.html"/>
      <url>/posts/1101.html</url>
      
        <content type="html"><![CDATA[<h1 id="主定理的内容"><a href="#主定理的内容" class="headerlink" title="主定理的内容"></a>主定理的内容</h1><p>《算法导论》中提到了主定理，用来分析<strong>分治</strong>方法带来的<br><strong>主定理是解决递归时间复杂度的一种直接方法</strong>，<strong>适合于以下类型的递推公式</strong><br>$$T(n) = aT(n/b) + O(n^d)  （a &gt;= 1 且 b &gt; 1）$$</p><p>其中$n$为问题规模，$a$为递推的子问题数量，$n/b$为每个子问题的规模（假设每个子问题的规模基本一样），$O(n^d)$为递推以外进行的计算工作量</p><p>那么问题的<font color=red size=3 face=STHeit>时间复杂度$T(n)$</font>为</p><ul><li>如果$a &lt; b^d$，则$T(n) = O(n^d)$</li><li>如果$a = b^d$，则$T(n) = O(n^dlogn)$</li><li>如果$a &gt; b^d$，则$T(n) = O(n^{log_b^a})$</li></ul><hr><p>说明：像$T(n) = T(\sqrt{n}) + 1$这个公式就不符合上面的递归类型，不过它可以通过换元得到上面形式，这里不再赘述</p><h1 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h1><p><strong>例：二分查找</strong></p><p>$T(n) = T(n/2) + O(n^0)$  假设每个子问题的规模基本一样</p><p> $a = 1, b = 2, d = 0,b^d = 1$ ，所以 $T(n) = O(logn)$ </p><hr><p><strong>例：归并排序</strong></p><p>$T(n) = 2T(n/2) + O(n^1)$  假设每个子问题的规模基本一样</p><p> $a = 2, b = 2, d = 1,b^d = 2$ ，所以 $T(n) = O(nlogn)$ </p><hr><p><strong>例：LeetCode 236. 二叉树的最近公共祖先</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> p<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> left <span class="token operator">=</span>  <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> p <span class="token operator">||</span> root <span class="token operator">==</span> q<span class="token punctuation">)</span>             <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> right<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> left<span class="token punctuation">;</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>$T(n) = 2T(n/2) + O(n^0)$  假设每个子问题的规模基本一样，也就是说我们可以<font color=red size=3 face=STHeit>假设左右子树的结点数相同</font></p><p> $a = 2, b = 2, d = 0,b^d = 1$ ，所以 $T(n) = O(n)$ </p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer | 数组中重复的数字</title>
      <link href="/posts/1010.html"/>
      <url>/posts/1010.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">原题链接</a></p><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><strong>(基于交换)</strong> $O(n)$<br>相似题 <a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">LeetCode 41.第一个缺失的正数</a></p><ul><li>遍历数组，把元素i放到下标为i的位置上，如果下标为i的位置上元素值不是i，那就把当前位置和下标为i的数进行交换，那么i就到了正确的位置，否则就继续往下遍历数组</li><li>再遍历一次数组，如果元素i和它的下标不相等，说明元素i就是重复的元素了，此题我们通过指针返回其中一个重复元素就可以了</li></ul><p><strong>核心代码</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">!=</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> numbers<span class="token punctuation">[</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>详细解释</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp">  下标：<span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span>  数组：<span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">4</span> <span class="token number">1</span>遍历数组  i <span class="token operator">=</span> <span class="token number">0</span>时  nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> 那<span class="token number">2</span>应该到下标为<span class="token number">2</span>的位置，所以和<span class="token number">4</span>交换  交换后：<span class="token number">4</span> <span class="token number">3</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">1</span>  继续看换过来后nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span>是否在合适的位置，<span class="token number">4</span>应该到下标为<span class="token number">4</span>的位置，所以和<span class="token number">1</span>交换  交换后<span class="token operator">:</span> <span class="token number">1</span> <span class="token number">3</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">4</span>  同理我们继续把<span class="token number">1</span>和<span class="token number">3</span>交换  交换后<span class="token operator">:</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">4</span>  然后继续把<span class="token number">3</span>和<span class="token number">4</span>交换  交换后<span class="token operator">:</span> <span class="token number">4</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span>  注意：此时nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span>，已经不需要放到下标为<span class="token number">4</span>的位置了，因为已经有个<span class="token number">4</span>放在那了         因此i <span class="token operator">=</span> <span class="token number">0</span>这种情况结束  i <span class="token operator">=</span> <span class="token number">1</span>时  继续上面的过程  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度是$O(n)$，空间复杂度是$O(1)$</p><h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// Parameters:</span>    <span class="token comment" spellcheck="true">//        numbers:     an array of integers</span>    <span class="token comment" spellcheck="true">//        length:      the length of array numbers</span>    <span class="token comment" spellcheck="true">//        duplication: (Output) the duplicated number in the array number</span>    <span class="token comment" spellcheck="true">// Return value:       true if the input is valid, and there are some duplications in the array number</span>    <span class="token comment" spellcheck="true">//                     otherwise false</span>    <span class="token keyword">bool</span> <span class="token function">duplicate</span><span class="token punctuation">(</span><span class="token keyword">int</span> numbers<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> duplication<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Judge if the input is valid</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Make the element in the right position</span>        <span class="token comment" spellcheck="true">// Such as element 3 should in index 3</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">!=</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> numbers<span class="token punctuation">[</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// return a duplicate number by reference (point)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">*</span>duplication <span class="token operator">=</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他方法：</p><ul><li>排序：时间复杂度是$O(nlogn)$，空间复杂度是$O(1)$</li><li>创建一个新数组：时间复杂度是$O(n)$，空间复杂度是$O(n)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过数据范围反推算法复杂度和算法内容</title>
      <link href="/posts/12489.html"/>
      <url>/posts/12489.html</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><ul><li>ACM比赛或者互联网笔试题的时间限制是1秒或2秒。  </li><li>在这种情况下，C++代码中的操作次数控制在$10^7$为最佳。</li></ul><h1 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h1><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><ol><li>n ≤ 30 =&gt;指数级别, dfs+剪枝，状态压缩dp</li><li>n ≤100 =&gt; O((n_{}^{3}))，floyd，dp</li><li>n ≤ 1000 =&gt; O((n_{}^{2}))，O((n_{}^{2}logn))，dp，二分</li><li>n ≤ 10000 =&gt; O((n^{2}\sqrt{n}))，块状链表</li><li>n ≤ $10_{}^{5}$ =&gt; O((nlogn)) ，各种sort，线段树、树状数组、set/map、heap、dijkstra+heap、spfa、求凸包、求半平面交、二分</li><li>n ≤ $10_{}^{6}$ =&gt;O((n))的做法：hash、双指针扫描、kmp、AC自动机<br>常数小的 O((nlogn))的做法：sort、树状数组、heap、dijkstra、spfa</li><li>n ≤ $10_{}^{7}$ =&gt; O((n))，双指针扫描、kmp、AC自动机、线性筛素数</li><li>n ≤ $10_{}^{9}$ =&gt; O((\sqrt{n}))，判断质数</li><li>n ≤ $10_{}^{18}$ =&gt; O((logn))，最大公约数  </li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
