<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>卡特兰数专题</title>
      <link href="/posts/49535.html"/>
      <url>/posts/49535.html</url>
      
        <content type="html"><![CDATA[<p>2018.09 大三上 <a href="https://weisenhui.top/file/combinatorics.pdf">组合数学课堂讲义</a></p><h1 id="卡特兰数定义"><a href="#卡特兰数定义" class="headerlink" title="卡特兰数定义"></a>卡特兰数定义</h1><div align=center><img src="https://img-blog.csdnimg.cn/20200508154142724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_40,text_ICBAU0hXRUkgIA==,size_25,color_FFFFFF,t_50,g_ne" width="92%"/><p></p></div><h1 id="卡特兰数的性质"><a href="#卡特兰数的性质" class="headerlink" title="卡特兰数的性质"></a>卡特兰数的性质</h1><div align=center><img src="https://img-blog.csdnimg.cn/20200508172112952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_40,text_ICBAU0hXRUkgIA==,size_25,color_FFFFFF,t_50,g_ne" width="92%"/><p></p></div><p>记住前几项：<code>1，1，2，5，14</code></p><p>==卡特兰数问题一般都存在匹配关系==</p><p>（1）求组合数形式<br>$$<br>C_n = \frac{\binom{2n}{n}}{n + 1}<br>$$<br>求组合数有四种方法，详见：<a href="https://blog.csdn.net/qq_43827595/article/details/102084068" target="_blank" rel="noopener">常用算法代码模版4—数学知识</a><br>（2）递推形式<br>$$<br>C_n =  \frac{4n-2}{n + 1}C_{n-1}，\text{其中}C_0 = C_1 = 1<br>$$<br>可以用递归来求，也可以用记忆化数组来求（空间换时间）</p><p>（3）基本公式<br>$$<br>C_{n+1} = \sum _ {i = 0} ^ n C_i C _ {n - i}，\text{其中}C_0 = C_1 = 1<br>$$<br>用二重循环求</p><p><strong>说明</strong>：通常满足上面任意公式的都是卡特兰数</p><p><a href="https://blog.csdn.net/weixin_44336954/article/details/96976153" target="_blank" rel="noopener">卡特兰数四个公式（简单）</a></p><p><strong>注意</strong>：由于卡特兰数增长速度较快，当 n 等于 17 时，卡特兰数将会超过 int 最大值，造成溢出（Python 除外），建议用long long来存。对于 Java 语言来说，可以使用 BigInteger 来计算大整数。</p><hr><div align=center><img src="https://img-blog.csdnimg.cn/20200508162116468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_40,text_ICBAU0hXRUkgIA==,size_25,color_FFFFFF,t_50,g_ne" width="92%"/><p></p></div><p>—— 摘自<a href="https://en.wikipedia.org/wiki/Catalan_number" target="_blank" rel="noopener">Wikipedia</a></p><hr><h1 id="卡特兰数证明（折线法）（n和m相同）"><a href="#卡特兰数证明（折线法）（n和m相同）" class="headerlink" title="卡特兰数证明（折线法）（n和m相同）"></a>卡特兰数证明（折线法）（n和m相同）</h1><p> 卡特兰数$C_n = \frac{\binom{2n}{n}}{n + 1} = \frac{C(2n,n)}{n + 1}$ </p><div align=center><img src="https://img-blog.csdnimg.cn/20200508160048291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_40,text_ICBAU0hXRUkgIA==,size_25,color_FFFFFF,t_50,g_ne" width="92%"/><p></p></div><h1 id="LeetCode-96-不同的二叉搜索树"><a href="#LeetCode-96-不同的二叉搜索树" class="headerlink" title="LeetCode 96. 不同的二叉搜索树"></a>LeetCode 96. 不同的二叉搜索树</h1><p><a href="https://blog.csdn.net/qq_43827595/article/details/106001282" target="_blank" rel="noopener">LeetCode 题解 | 96. 不同的二叉搜索树（卡特兰数 C++）</a></p><h1 id="n-1-个叶子节点能够构成多少种形状不同的满二叉树"><a href="#n-1-个叶子节点能够构成多少种形状不同的满二叉树" class="headerlink" title="n + 1 个叶子节点能够构成多少种形状不同的满二叉树"></a>n + 1 个叶子节点能够构成多少种形状不同的满二叉树</h1><p>满二叉树的每个非叶子结点一定都有左右子树（<code>匹配关系</code>）</p><p>使用<strong>深度优先搜索</strong>这个满二叉树，向左扩展时标记为 +1，向右扩展时标记为 -1</p><p>一个卡特兰序列(n + 1个点)对应一棵满二叉树</p><div align=center><img src="https://img-blog.csdnimg.cn/20200508193508970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_40,text_ICBAU0hXRUkgIA==,size_25,color_FFFFFF,t_50,g_ne" width="92%"/><p></p></div><h1 id="例：买票"><a href="#例：买票" class="headerlink" title="例：买票"></a>例：买票</h1><p>绘画展览门票每张5元，如果有2n个人排队购票，每人一张，并且其中一半人恰有5元钱，另一半人恰有10元钱，而票房无零钱可找，那么如何将这2n个人排成一列，顺次购票，使得不至于因票房无零钱可找而耽误时间，应该采用什么算法解决呢？</p><h1 id="例：图书馆借还书"><a href="#例：图书馆借还书" class="headerlink" title="例：图书馆借还书"></a>例：图书馆借还书</h1><p>在图书馆一共6个人在排队，3个还《面试宝典》一书，3个在借《面试宝典》一书，图书馆此时没有了面试宝典了，求他们排队的总数？</p><p>解：队伍是排成一列的，联想Catalan证明的图</p><p>$$h(3)=6!/(3!*4!)=5$$</p><p>总数为<br>$$h(3) * 3! * 3!=180$$</p><p>注意：算<strong>种类</strong>时，最后要乘以3!和3!</p><h1 id="例：出栈顺序"><a href="#例：出栈顺序" class="headerlink" title="例：出栈顺序"></a>例：出栈顺序</h1><p>一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列?</p><p><strong>思路</strong><br>将问题转化为：入栈的数的个数总是要大于或者等于出栈数的个数。进栈相当于+1，出栈相当于-1</p><p>如：序列1 2 3的出栈序列可以表示为<code>+1,-1,+1,+1,-1,-1</code></p><div align=center><img src="https://img-blog.csdnimg.cn/20200508191933386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_40,text_ICBAU0hXRUkgIA==,size_25,color_FFFFFF,t_50,g_ne" width="92%"/><p></p></div><h1 id="例：括号匹配"><a href="#例：括号匹配" class="headerlink" title="例：括号匹配"></a>例：括号匹配</h1><p>n 对括号，则有多少种 “括号匹配” 的括号序列？</p><p><strong>思路</strong><br>左括号看成 +1，右括号看成 -1，类似进出栈</p><h1 id="例：2-n矩阵（每行递增，每列递增）"><a href="#例：2-n矩阵（每行递增，每列递增）" class="headerlink" title="例：2*n矩阵（每行递增，每列递增）"></a>例：2*n矩阵（每行递增，每列递增）</h1><p><img src="https://img-blog.csdnimg.cn/20200508163457859.png" alt="在这里插入图片描述"><br><strong>思路</strong><br>把第一排看作进栈+1，第二排看作出栈-1，同时要一直保证第一排填充的数大于等于第二排填充的数（递增要求）<br>按照 1 到 2n 的顺序填入矩阵，$1$ 放第一排，对应卡特兰序列中$x_1=+1$，…</p><p>显然：长度为2n的卡特兰序列与2 X n矩阵的填法一一对应</p><div align=center><img src="https://img-blog.csdnimg.cn/20200508203016671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_40,text_ICBAU0hXRUkgIA==,size_25,color_FFFFFF,t_50,g_ne" width="92%"/><p></p></div><h1 id="例：典型例题"><a href="#例：典型例题" class="headerlink" title="例：典型例题"></a>例：典型例题</h1><div align=center><img src="https://img-blog.csdnimg.cn/2020050816362253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_40,text_ICBAU0hXRUkgIA==,size_25,color_FFFFFF,t_50,g_ne" width="92%"/><p></p></div><h1 id="提升题：电影购票（n和m不同）"><a href="#提升题：电影购票（n和m不同）" class="headerlink" title="提升题：电影购票（n和m不同）"></a>提升题：电影购票（n和m不同）</h1><blockquote><p>当进栈 +1 有 m 个， 出栈 -1 有 n 个时，序列共有$C_{m+n} ^ m - C _ {m + n} ^ {m + 1}$种可能性</p></blockquote><p>电影票一张 50 coin，且售票厅没有 coin。m 个人各自持有 50 coin，n 个人各自持有 100 coin。则有多少种排队方式，可以让每个人都买到电影票？</p><p><strong>思路</strong><br>持有 50 coin 的人看作 +1，持有 100 coin 的人看作 -1，类似进出栈问题<br><code>与卡特兰数不同的是，这里有 m 个 +1，有 n 个 -1</code></p><p>我们还是可以用折线法来解决这个问题：</p><div align=center><img src="https://img-blog.csdnimg.cn/20200508200634721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_40,text_ICBAU0hXRUkgIA==,size_25,color_FFFFFF,t_50,g_ne" width="92%"/><p></p></div><p>由于排队有先后顺序，所以总共有 $(C_{m+n} ^ m - C _ {m + n} ^ {m + 1}) * m! * n !$种可能 </p><p>注：$C_{m+n} ^ m - C _ {m + n} ^ {m + 1}$这部分直接推导即可</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a href="http://lanqi.org/interests/10939/" target="_blank" rel="noopener">卡特兰数 — 计数的映射方法的伟大胜利</a><br>[2] <a href="https://blog.csdn.net/zP1nG/article/details/78149209" target="_blank" rel="noopener">【证明】卡特兰数（折线法）</a><br>[3] <a href="https://blog.csdn.net/sinat_35512245/article/details/53924772" target="_blank" rel="noopener">一道面试题到卡特兰数及其应用</a><br>[4] <a href="https://blog.csdn.net/zuzhiang/article/details/77966726" target="_blank" rel="noopener">卡特兰数（catalan数）总结 （卡特兰大数、卡特兰大数取模、卡特兰数应用）</a><br>[5] <a href="https://blog.csdn.net/Morning_Glory_JR/article/details/102760802?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-3" target="_blank" rel="noopener">卡特兰(Catalan)数入门详解</a> —— 例题的证明讲得不错<br>[6] <a href="https://leetcode-cn.com/circle/article/lWYCzv/" target="_blank" rel="noopener">LeetCode -「算法入门笔记」卡特兰数</a></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业季的一点思考</title>
      <link href="/posts/32615.html"/>
      <url>/posts/32615.html</url>
      
        <content type="html"><![CDATA[<h1 id="不经历而难以彻悟"><a href="#不经历而难以彻悟" class="headerlink" title="不经历而难以彻悟"></a>不经历而难以彻悟</h1><p><strong>听了很多道理我们都过不好一生，就是因为很多道理不经历是不会懂的</strong>。</p><p>不管是别人告诉你，还是你从哪里读到，都不算你真正的理解。只有经历过感受过，你才会把这些道理刻在脑回路上，像一个个函数，针对特定的生活场景（参数），调用特定的道理（函数）。函数多了之后，你面对什么样的场景都能应对自如，从而给人留下成熟、淡定自如的印象。</p><p>所以人生就是一个不断丰富自己函数库的过程，只有不断的去经历，经历自己不曾经历的，体验自己不敢体验的，才能让自己的心脑体都更强大。而且，体验的过程本身就是一件有趣的事，不是吗？</p><p>作者：geekplux<br>链接：<a href="https://geekplux.com/2018/06/01/the-summary-of-graduate-career" target="_blank" rel="noopener">https://geekplux.com/2018/06/01/the-summary-of-graduate-career</a></p><h1 id="为什么越优秀的人越谦虚"><a href="#为什么越优秀的人越谦虚" class="headerlink" title="为什么越优秀的人越谦虚"></a>为什么越优秀的人越谦虚</h1><div align=center><img src="https://img-blog.csdnimg.cn/20200426101546488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_40,text_ICBAU0hXRUkgIA==,size_25,color_FFFFFF,t_50,g_ne" width="77%"/><p></p></div><p>参照物不同</p><p>当他说他还有很多东西不会的时候，他是在和XX大神相比，还有很多东西要学习，在你眼里他是100分，你是60分，可在他眼里他才60分，而你36分罢了</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Installed package won&#39;t import in notebook</title>
      <link href="/posts/29810.html"/>
      <url>/posts/29810.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h1><p>我在终端使用pip3 install seaborn库，但奇怪的是我打开jupyter notebook时，它还是说我没有导入成功，坑！！！</p><div align=center><img src="https://img-blog.csdnimg.cn/20200316144943972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_40,text_ICBAU0hXRUkgIA==,size_25,color_FFFFFF,t_50,g_nw" width="77%"/></div><h1 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h1><p>在mac中打开访达进入下面文件夹</p><pre><code>/usr/local/share/jupyter/kernels/python3</code></pre><p>打开kernel.json，进行如下修改</p><p>修改前：</p><div align=center><img src="https://img-blog.csdnimg.cn/20200316145135549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_40,text_ICBAU0hXRUkgIA==,size_25,color_FFFFFF,t_50,g_nw" width="77%"/></div><p>修改后</p><p>将<code>python</code>修改成<code>/usr/local/bin/python3</code></p><div align=center><img src="https://img-blog.csdnimg.cn/2020031614525377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_40,text_ICBAU0hXRUkgIA==,size_25,color_FFFFFF,t_50,g_nw" width="77%"/></div><p>重启jupyter notebook，可以发现不会再报错了</p><div align=center><img src="https://img-blog.csdnimg.cn/20200316145424552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_40,text_ICBAU0hXRUkgIA==,size_25,color_FFFFFF,t_50,g_nw" width="77%"/></div><h1 id="教训："><a href="#教训：" class="headerlink" title="教训："></a>教训：</h1><p>遇到报错，用Google去搜索，然后去GitHub里面的issues找答案，里面会有很多大佬帮你解决问题，而且回答质量非常高。事实证明解决问题看issues比看别人的中文二手博客要高效10倍</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><ul><li><a href="https://github.com/jupyter/notebook/issues/2359" target="_blank" rel="noopener">Installed package won’t import in notebook #2359</a></li></ul><div align=center><img src="https://img-blog.csdnimg.cn/20200316145734712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_40,text_ICBAU0hXRUkgIA==,size_25,color_FFFFFF,t_50,g_nw" width="77%"/></div>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题解决 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 236.二叉树的最近公共祖先</title>
      <link href="/posts/1234.html"/>
      <url>/posts/1234.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述（中等难度）"><a href="#题目描述（中等难度）" class="headerlink" title="题目描述（中等难度）"></a>题目描述（中等难度）</h1><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">原题链接</a><br><img src="https://img-blog.csdnimg.cn/20200212170139454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI3NTk1,size_16,color_FFFFFF,t_70" alt=""></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><strong>(递归)</strong> $O(n)$</p><p>当我们用递归去做这个题时不要被题目误导，应该要明确一点<br><code>这个函数的功能有三个</code>：给定两个节点 $p$ 和 $q$</p><ol><li>如果 $p$ 和 $q$ 都存在，则返回它们的公共祖先；</li><li>如果只存在一个，则返回存在的一个；</li><li>如果 $p$ 和 $q$ 都不存在，则返回NULL</li></ol><p>本题说给定的两个节点都存在，那自然还是能用上面的函数来解决</p><p><strong>具体思路</strong>：<br>（1） 如果当前结点 $root$ 等于NULL，则直接返回NULL<br>（2） 如果 $root$ 等于 $p$ 或者 $q$ ，那这棵树一定返回 $p$ 或者 $q$<br>（3） 然后递归左右子树，因为是递归，使用函数后可认为左右子树已经算出结果，用 $left$ 和 $right$ 表示<br>（4） 此时若$left$为空，那最终结果只要看 $right$，若 $right$ 为空，那最终结果只要看 $left$<br>（5） 如果 $left$ 和 $right$ 都非空，因为只给了 $p$ 和 $q$ 两个结点，都非空，说明一边一个，因此 $root$ 是他们的最近公共祖先<br>（6） 如果 $left$ 和 $right$ 都为空，则返回空（其实已经包含在前面的情况中了）</p><p>时间复杂度是$O(n)$：每个结点最多遍历一次或用主定理，空间复杂度是$O(n)$：需要系统栈空间</p><h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> p<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 可认为左右子树已经实现了函数的功能</span>        TreeNode<span class="token operator">*</span> left <span class="token operator">=</span>  <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> p <span class="token operator">||</span> root <span class="token operator">==</span> q<span class="token punctuation">)</span>             <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> right<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> left<span class="token punctuation">;</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// p和q在两侧</span>            <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 必须有返回值</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
