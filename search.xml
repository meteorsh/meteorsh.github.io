<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MasterTheorem-递归时间复杂度分析</title>
      <link href="/posts/47306.html"/>
      <url>/posts/47306.html</url>
      
        <content type="html"><![CDATA[<h1 id="主定理的内容"><a href="#主定理的内容" class="headerlink" title="主定理的内容"></a>主定理的内容</h1><p>《算法导论》中提到了主定理，用来分析<strong>分治</strong>方法带来的<br><strong>主定理是解决递归时间复杂度的一种直接方法</strong>，<strong>适合于以下类型的递推公式</strong><br>$$T(n) = aT(n/b) + O(n^d)  （a &gt;= 1 且 b &gt; 1）$$</p><p>其中$n$为问题规模，$a$为递推的子问题数量，$n/b$为每个子问题的规模（假设每个子问题的规模基本一样），$O(n^d)$为递推以外进行的计算工作量</p><p>那么问题的<font color=red size=3 face=STHeit>时间复杂度$T(n)$</font>为</p><ul><li>如果$a &lt; b^d$，则$T(n) = O(n^d)$</li><li>如果$a = b^d$，则$T(n) = O(n^dlogn)$</li><li>如果$a &gt; b^d$，则$T(n) = O(n^{log_b^a})$</li></ul><hr><p>说明：像$T(n) = T(\sqrt{n}) + 1$这个公式就不符合上面的递归类型，不过它可以通过换元得到上面形式，这里不再赘述</p><h1 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h1><p><strong>例：二分查找</strong></p><p>$T(n) = T(n/2) + O(n^0)$  假设每个子问题的规模基本一样</p><p> $a = 1, b = 2, d = 0,b^d = 1$ ，所以 $T(n) = O(logn)$ </p><hr><p><strong>例：归并排序</strong></p><p>$T(n) = 2T(n/2) + O(n^1)$  假设每个子问题的规模基本一样</p><p> $a = 2, b = 2, d = 1,b^d = 2$ ，所以 $T(n) = O(nlogn)$ </p><hr><p><strong>例：LeetCode 236. 二叉树的最近公共祖先</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> p<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> left <span class="token operator">=</span>  <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> p <span class="token operator">||</span> root <span class="token operator">==</span> q<span class="token punctuation">)</span>             <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> right<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> left<span class="token punctuation">;</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>$T(n) = 2T(n/2) + O(n^0)$  假设每个子问题的规模基本一样，也就是说我们可以<font color=red size=3 face=STHeit>假设左右子树的结点数相同</font></p><p> $a = 2, b = 2, d = 0,b^d = 1$ ，所以 $T(n) = O(n)$ </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer | 数组中重复的数字</title>
      <link href="/posts/1010.html"/>
      <url>/posts/1010.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">原题链接</a></p><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><strong>(基于交换)</strong> $O(n)$<br>相似题 <a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">LeetCode 41.第一个缺失的正数</a></p><ul><li>遍历数组，把元素i放到下标为i的位置上，如果下标为i的位置上元素值不是i，那就把当前位置和下标为i的数进行交换，那么i就到了正确的位置，否则就继续往下遍历数组</li><li>再遍历一次数组，如果元素i和它的下标不相等，说明元素i就是重复的元素了，此题我们通过指针返回其中一个重复元素就可以了</li></ul><p><strong>核心代码</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">!=</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> numbers<span class="token punctuation">[</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>详细解释</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp">  下标：<span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span>  数组：<span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">4</span> <span class="token number">1</span>遍历数组  i <span class="token operator">=</span> <span class="token number">0</span>时  nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> 那<span class="token number">2</span>应该到下标为<span class="token number">2</span>的位置，所以和<span class="token number">4</span>交换  交换后：<span class="token number">4</span> <span class="token number">3</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">1</span>  继续看换过来后nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span>是否在合适的位置，<span class="token number">4</span>应该到下标为<span class="token number">4</span>的位置，所以和<span class="token number">1</span>交换  交换后<span class="token operator">:</span> <span class="token number">1</span> <span class="token number">3</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">4</span>  同理我们继续把<span class="token number">1</span>和<span class="token number">3</span>交换  交换后<span class="token operator">:</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">4</span>  然后继续把<span class="token number">3</span>和<span class="token number">4</span>交换  交换后<span class="token operator">:</span> <span class="token number">4</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span>  注意：此时nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span>，已经不需要放到下标为<span class="token number">4</span>的位置了，因为已经有个<span class="token number">4</span>放在那了         因此i <span class="token operator">=</span> <span class="token number">0</span>这种情况结束  i <span class="token operator">=</span> <span class="token number">1</span>时  继续上面的过程  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度是$O(n)$，空间复杂度是$O(1)$</p><h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// Parameters:</span>    <span class="token comment" spellcheck="true">//        numbers:     an array of integers</span>    <span class="token comment" spellcheck="true">//        length:      the length of array numbers</span>    <span class="token comment" spellcheck="true">//        duplication: (Output) the duplicated number in the array number</span>    <span class="token comment" spellcheck="true">// Return value:       true if the input is valid, and there are some duplications in the array number</span>    <span class="token comment" spellcheck="true">//                     otherwise false</span>    <span class="token keyword">bool</span> <span class="token function">duplicate</span><span class="token punctuation">(</span><span class="token keyword">int</span> numbers<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> duplication<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Judge if the input is valid</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Make the element in the right position</span>        <span class="token comment" spellcheck="true">// Such as element 3 should in index 3</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">!=</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> numbers<span class="token punctuation">[</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// return a duplicate number by reference (point)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">*</span>duplication <span class="token operator">=</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他方法：</p><ul><li>排序：时间复杂度是$O(nlogn)$，空间复杂度是$O(1)$</li><li>创建一个新数组：时间复杂度是$O(n)$，空间复杂度是$O(n)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过数据范围反推算法复杂度和算法内容</title>
      <link href="/posts/12489.html"/>
      <url>/posts/12489.html</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><ul><li>ACM比赛或者互联网笔试题的时间限制是1秒或2秒。  </li><li>在这种情况下，C++代码中的操作次数控制在$10^7$为最佳。</li></ul><h1 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h1><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><ol><li>n ≤ 30 =&gt;指数级别, dfs+剪枝，状态压缩dp</li><li>n ≤100 =&gt; O((n_{}^{3}))，floyd，dp</li><li>n ≤ 1000 =&gt; O((n_{}^{2}))，O((n_{}^{2}logn))，dp，二分</li><li>n ≤ 10000 =&gt; O((n^{2}\sqrt{n}))，块状链表</li><li>n ≤ $10_{}^{5}$ =&gt; O((nlogn)) ，各种sort，线段树、树状数组、set/map、heap、dijkstra+heap、spfa、求凸包、求半平面交、二分</li><li>n ≤ $10_{}^{6}$ =&gt;O((n))的做法：hash、双指针扫描、kmp、AC自动机<br>常数小的 O((nlogn))的做法：sort、树状数组、heap、dijkstra、spfa</li><li>n ≤ $10_{}^{7}$ =&gt; O((n))，双指针扫描、kmp、AC自动机、线性筛素数</li><li>n ≤ $10_{}^{9}$ =&gt; O((\sqrt{n}))，判断质数</li><li>n ≤ $10_{}^{18}$ =&gt; O((logn))，最大公约数  </li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
